// Entry point
?start: globalcontext*

////////////////////////////////////////////////////////////////////////////////
// Terminals.
////////////////////////////////////////////////////////////////////////////////

// Normal assigment op
ASSIGNMENT: "="

// Comparison ops - ordering is important here for correct tokenization
COMPARISON: ">=" | "<=" | "!=" | "!$=" | "==" | "$=" | ">" | "<"

// Arithmetic ops
ARITHMETIC: "+" | "*" | "-" | "/"

// Logical Ops
LOGICAL: "||" | "&&"

// Bitwise ops
BITWISE: "^" | "&" | "|"

// PREFIX ops
PREFIX: "~" | "!"

// POSTFIX ops
POSTFIX: "++" | "--"

// Cumulative ops
CUMULATIVE: "+=" | "-="

PARENTHESESEXPLICIT: "("

// Keywords that should be differentiated
RETURN: "return"
IF: "if"
BREAK: "break"
PACKAGE: "package"
FORLOOP: "for"
ARRAY: "["
SWITCHSTRING: "switch$"
SWITCHCASE: "case"
WHILELOOP: "while"
DEFAULTCASE: "default"
NEWOBJECT: "new"
FIELDASSIGNMENT: NAME
ELSE: "else"
ELSEIF: "else if"

// Exclude dollar sign from the terminal intentionally
GLOBALREF: NAME ("::" NAME)*

// Exclude percent sign from the terminal intentionally
LOCALREF: NAME

FIELDREF: "."

// Torque script (as of T2 anyway) only supports inline comments
COMMENT: /\/\/.*/

FUNCTIONCALL: NAME ("::" NAME)*
FUNCTIONDECLARATION: NAME ("::" NAME)*

////////////////////////////////////////////////////////////////////////////////
// Rules.
////////////////////////////////////////////////////////////////////////////////

globalcontext: COMMENT | package | globalassignment | localassignment | rvaluepostfix ";" | newobject | functioncall ";" | newobject ";" | switchstring | whileloopbrace | whileloopnobrace | forloopbrace | forloopnobrace | ifbrace | ifnobrace | functiondeclaration
packagecontext: COMMENT | globalassignment | localassignment | functioncall ";" | switchstring | whileloopbrace | whileloopnobrace | forloopbrace | forloopnobrace | ifbrace | ifnobrace | functiondeclaration

// Like the global context but functions cannot be declared inside ie. for loops, other functions, etc
codeblock: COMMENT | globalassignment | localassignment | rvaluepostfix ";" | functioncall ";" | newobject ";" | switchstring | whileloopbrace | whileloopnobrace | forloopbrace | forloopnobrace | break | return | ifbrace | ifnobrace

// Global & local assignments are allowed anywhere
globalassignment: globalref ASSIGNMENT rvalue ";"
localassignment: localref ASSIGNMENT rvalue ";"

// General purpose rule for handling local & globals
// These may be referenced as arrays in any configuration like: %localArr[%i] = 50;
localref: "%" LOCALREF (ARRAY rvalue ("," ARRAY)* "]")?
globalref: "$" GLOBALREF (ARRAY rvalue ("," ARRAY)* "]")?

rvaluepostfix: (localref | globalref) POSTFIX
rvalueprefix: PREFIX (localref | globalref | functioncall)

rvalueinternal: rvaluepostfix | rvalueprefix | ((NAME | NUMBER | ESCAPED_STRING | TAGGED_STRING | newobject | functioncall | localref | globalref | (rvalue (LOGICAL | ARITHMETIC | COMPARISON | BITWISE | ASSIGNMENT) rvalue)))
rvalue: rvalueinternal | (PARENTHESESEXPLICIT rvalueinternal ")")

callparameterlist: [rvalue]
callparameters: rvalue ("," rvalue)*

functioncall: FUNCTIONCALL "(" callparameters* ")"

functiondeclarationparameters: "%" LOCALREF ("," "%" LOCALREF)*
functiondeclaration: "function" FUNCTIONDECLARATION "(" functiondeclarationparameters* ")" "{" codeblock* "}"

return: RETURN rvalue* ";"
ifnobrace: IF "(" rvalue ")" codeblock elseif* else?
ifbrace: IF "(" rvalue ")" COMMENT? "{" codeblock* "}" elseif* else?
package: PACKAGE NAME COMMENT? "{" packagecontext* "};"
break: BREAK ";"
fieldassignment: FIELDASSIGNMENT (ARRAY rvalue ("," ARRAY)* "]")? "=" rvalue ";"

newobject: NEWOBJECT (NAME | ("(" NAME ")")) "(" NAME? ")" "{" (fieldassignment | newobject ";")* "}"

forloopbrace: FORLOOP "(" rvalue ";" rvalue ";" rvalue ")" COMMENT? "{" codeblock* "}"
forloopnobrace: FORLOOP "(" rvalue ";" rvalue ";" rvalue ")" COMMENT? codeblock

switchcases: ((SWITCHCASE rvalue) | DEFAULTCASE) ":" COMMENT? codeblock+
switchstring: SWITCHSTRING "(" rvalue ")" COMMENT? "{" switchcases+ "}"

whileloopbrace: WHILELOOP "(" rvalue ")" COMMENT? "{" codeblock* "}"
whileloopnobrace: WHILELOOP "(" rvalue ")" COMMENT? codeblock

else: elsebrace | elsenobrace
elsebrace: ELSE COMMENT? "{" codeblock* "}"
elsenobrace: ELSE COMMENT? codeblock

elseif: elseifbrace | elseifnobrace
elseifbrace: ELSEIF "(" rvalue ")" COMMENT? "{" codeblock* "}" else?
elseifnobrace: ELSEIF "(" rvalue ")" COMMENT? codeblock else?

////////////////////////////////////////////////////////////////////////////////
// Ignore whitespace.
////////////////////////////////////////////////////////////////////////////////
%ignore /[ \t\n\f\r]+/

////////////////////////////////////////////////////////////////////////////////
// From lark's common.lark; imports do not seem to work correctly when
// packaged.
////////////////////////////////////////////////////////////////////////////////

LCASE_LETTER: "a".."z"
UCASE_LETTER: "A".."Z"
LETTER: UCASE_LETTER | LCASE_LETTER
DIGIT: "0".."9"
NAME: ("_"|LETTER) ("_"|LETTER|DIGIT)*

INT: DIGIT+
NUMBER: ("+"|"-")? (FLOAT | INT)
DECIMAL: INT "." INT? | "." INT
_EXP: ("e"|"E") SIGNED_INT
FLOAT: INT _EXP | DECIMAL _EXP?
SIGNED_NUMBER: ["+"|"-"] NUMBER
SIGNED_INT: ["+"|"-"] INT

_STRING_INNER: /.*?/
_STRING_ESC_INNER: _STRING_INNER /(?<!\\)(\\\\)*?/
ESCAPED_STRING : "\"" _STRING_ESC_INNER "\""
TAGGED_STRING : "'" _STRING_ESC_INNER "'"
